<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>

    <style>
        .headingDiv {
            border: 5px outset grey;
            /* background-color: lightblue; */
            text-align: center;
        }
        
        .classImbTitle, .scaleImbTitle,  .objLocImbTitle{
            text-align: center;
        }

        svg {
            font: 10px sans-serif;
        }

        .background path {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        } 

        .foreground path {
            fill: none;
            stroke: steelblue;
        }

        .brush .extent  {
            fill-opacity: .3;
            stroke: #fff;
            shape-rendering: crispEdges;
        }

        .axis line,
        .axis path {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .axis text {
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
            cursor: move;
        }
    </style>
</head>

<body>
    <div class="headingDiv">
        <h1>Dataset Imbalance Graphical Suport Tool</h1>
        <p> Chosen dataset for analisys: <input type="file" onchange="loadFile()" /></p>
    </div>
    <div id="classImbDiv">
        <h2 class="classImbTitle">Class Imbalance</h1>
        <div id="horizBarDiv"></div>
        <div id="pieDiv"></div>
        <div id="lineDiv"></div>
    </div>
    <div id="scaleImbDiv">
        <h2 class="scaleImbTitle">Scale Imbalance</h1>
            <div id="parallelDiv"></div>
            <div id="stackedControlDiv">
                <p>Medium: </p><input type="number" id="down_thresh"><p>² to</p><input type="number" id="up_thresh"><p>² pixels</p>
            </div>
            <div id="stackedDiv">
            </div>
    </div>
    <div id="objLocImbDiv">
        <h2 class="objLocImbTitle">Object Location Imbalance</h1>

    </div>
    <!-- TODO: tirar <<DEBUG>> -->
    <div id="debugDiv">
        <div id="debugDiv1"></div>
        <div id="debugDiv2"></div>
        <div id="debugDiv3"></div>
        <div id="debugDiv4"></div>
        <div id="debugDiv5"></div>
        <div id="debugDiv6"></div>
    </div>

    <script src="http://d3js.org/d3.v3.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <script>
        //Loading all from google chart API that will be used
        google.charts.load('current', {'packages':['bar']});
        google.charts.load('current', {'packages':['corechart']});
        google.charts.load('current', {'packages':['table']}); //TODO: tirar <<DEBUG>>

        //Some globals that every chart can access
        var current_selected_classes = [];

        //open the file uploaded by user
        var reader = new FileReader();  
    
        function loadFile() {      
            var file = document.querySelector('input[type=file]').files[0];
            //TODO: tirar <<DEBUG>>
            console.log(file.name);

            reader.addEventListener("load", parseFile, false);
            if (file) {
                reader.readAsText(file);
            }
        }
    
        //Parse the uploaded JSON
        function parseFile(){
            var data_json = JSON.parse(reader.result);
            console.log(data_json);
            // reading the data and formatting in order to be easier to work with it in google charts
            dataset_info = new google.visualization.DataTable();
            dataset_info.addColumn('string', 'contributor');
            dataset_info.addColumn('string', 'date_created');
            dataset_info.addColumn('string', 'description');
            dataset_info.addColumn('string', 'url');
            dataset_info.addColumn('string', 'version');
            dataset_info.addColumn('number', 'year');

            dataset_info.addRow([data_json.info.contributor, 
                        data_json.info.date_created,
                        data_json.info.description,
                        data_json.info.url,
                        data_json.info.version,
                        data_json.info.year]);

            // TODO
            // dataset_licenses = ;

            dataset_categories = new google.visualization.DataTable();
            dataset_categories.addColumn('number', 'id');
            dataset_categories.addColumn('string', 'name');
            dataset_categories.addColumn('string', 'supercategory');

            for (var i = 0; i < data_json.categories.length; i++) {
                dataset_categories.addRow([data_json.categories[i].id,
                                            data_json.categories[i].name,
                                            data_json.categories[i].supercategory]);
            }

            dataset_images = new google.visualization.DataTable();
            dataset_images.addColumn('string', 'id');
            dataset_images.addColumn('number', 'width');
            dataset_images.addColumn('number', 'height');
            dataset_images.addColumn('string', 'file_name');
            dataset_images.addColumn('number', 'license');
            dataset_images.addColumn('string', 'flickr_url');
            dataset_images.addColumn('string', 'coco_url');
            dataset_images.addColumn('string', 'date_captured');

            dataset_ImgsIds = []


            for (var i = 0; i < data_json.images.length; i++) {
                dataset_images.addRow([data_json.images[i].id,
                                        data_json.images[i].width,
                                        data_json.images[i].height,
                                        data_json.images[i].file_name,
                                        data_json.images[i].license,
                                        data_json.images[i].flickr_url,
                                        data_json.images[i].coco_url,
                                        data_json.images[i].date_captured]);
                dataset_ImgsIds.push(data_json.images[i].id)
            }

            dataset_annotations = new google.visualization.DataTable();
            dataset_annotations.addColumn('number', 'area');
            dataset_annotations.addColumn('number', 'topLeftX');
            dataset_annotations.addColumn('number', 'topLeftY');
            dataset_annotations.addColumn('number', 'width');
            dataset_annotations.addColumn('number', 'height');
            dataset_annotations.addColumn('number', 'category_id');
            dataset_annotations.addColumn('number', 'id');
            dataset_annotations.addColumn('string', 'image_id');
            dataset_annotations.addColumn('number', 'is_crowd');
            dataset_annotations.addColumn('number', 'center_x');
            dataset_annotations.addColumn('number', 'center_y');
            // dataset_categories.addColumn('????', 'segmentation');
            dataset_catToImgs = {}

            for (var i = 0; i < data_json.annotations.length; i++) {
                var center_x = data_json.annotations[i].bbox[0] + Math.round(data_json.annotations[i].bbox[2] / 2);
                var center_y = data_json.annotations[i].bbox[1] + Math.round(data_json.annotations[i].bbox[3] / 2);
                dataset_annotations.addRow([data_json.annotations[i].area,
                                            data_json.annotations[i].bbox[0],
                                            data_json.annotations[i].bbox[1],
                                            data_json.annotations[i].bbox[2],
                                            data_json.annotations[i].bbox[3],
                                            data_json.annotations[i].category_id,
                                            data_json.annotations[i].id,
                                            data_json.annotations[i].image_id,
                                            data_json.annotations[i].iscrowd,
                                            center_x,
                                            center_y]);
                if (dataset_catToImgs[data_json.annotations[i].category_id] != undefined){
                    dataset_catToImgs[data_json.annotations[i].category_id].push(data_json.annotations[i].image_id)
                } else {
                    dataset_catToImgs[data_json.annotations[i].category_id] = []
                    dataset_catToImgs[data_json.annotations[i].category_id].push(data_json.annotations[i].image_id)
                }
            }
            
            //TODO: tirar <<DEBUG>>
            // var table = new google.visualization.Table(document.getElementById('debugDiv1'));
            // table.draw(dataset_info, {showRowNumber: true, width: '100%', height: '100%'});
            // table = new google.visualization.Table(document.getElementById('debugDiv2'));
            // table.draw(dataset_categories, {showRowNumber: true, width: '100%', height: '100%'});
            // table = new google.visualization.Table(document.getElementById('debugDiv3'));
            // table.draw(dataset_annotations, {showRowNumber: true, width: '100%', height: '100%'});

            // TODO: talvez mostrar na tela as informações da base (dataset_info)
            
            //Draw each dashboard
            drawClassImbalanceDash(dataset_categories, dataset_annotations, dataset_catToImgs, dataset_ImgsIds);
            drawScaleImbalanceDash(dataset_annotations);
            drawLocationImbalanceDash(dataset_categories, dataset_annotations);
        }
        function updateAllCharts() {

        }

        function drawClassImbalanceDash(dataset_categories, dataset_annotations, dataset_catToImgs, dataset_ImgsIds){
            // group by class name
            var grouped_table = google.visualization.data.group(dataset_annotations, [5], 
                        [{'column': 5, 'aggregation': google.visualization.data.count, 'type': 'number'}]);
            
            // merging information to get class names
            var merged_table = google.visualization.data.join(dataset_categories, grouped_table,
                                'right', [[0,0]], [1], [1]);
            
            // removing the id column (only used to match both tables)
            merged_table.removeColumn(0);
            merged_table.setColumnLabel(0, "Class");
            merged_table.setColumnLabel(1, "Count");
            merged_table.sort({column: 1, desc: true});

            var options_horiz_bar = {
                chart: {
                    title: 'Total intances per class'//,
                    // subtitle: 'AMENO DORIME',
                },
                bars: 'horizontal', // Required for Material Bar Charts.
                // 'view': {'columns': [0, 3]}, //TODO: usar isso pra filtrar os dados do JSON!
                selectionMode: 'multiple',
                width: 900,
                height: 500
            };

            var horiz_chart = new google.charts.Bar(document.getElementById('horizBarDiv'));

            // The select handler. Call the chart's getSelection() method
            function selectHandler() {
                var selectedItem = horiz_chart.getSelection();
                if (selectedItem) {
                    if (selectedItem.length > 0) {
                        current_selected_classes = [];
                        selectedItem.forEach(element => {
                            current_selected_classes.push(element.row);
                        });
                        var old_selected_classes = [];
                        for (i of current_selected_classes) {
                            class_name = merged_table.getValue(i, 0);
                            for (var j = 0; j < dataset_categories.getNumberOfRows(); j++) {
                                if (class_name == dataset_categories.getValue(j, 1)) {
                                    old_selected_classes.push(j);
                                }
                            }
                        }
                        var view = new google.visualization.DataView(merged_table);
                        view.setRows(current_selected_classes);
                        pie_chart.draw(view, options_pie);
                        data_line = getLineChartValues(old_selected_classes, dataset_categories, dataset_catToImgs, dataset_ImgsIds);
                        line_chart.draw(data_line, options_line);
                    } else {
                        pie_chart.draw(merged_table, options_pie);
                        all_rows = [];
                        for (var i = 0; i < dataset_categories.getNumberOfRows(); i++) {
                            all_rows.push(i);
                        }
                        data_line = getLineChartValues(all_rows, dataset_categories, dataset_catToImgs, dataset_ImgsIds);
                        line_chart.draw(data_line, options_line);
                    }
                }
            }

            // Listen for the 'select' event, and call my function selectHandler() when
            // the user selects something on the chart.
            google.visualization.events.addListener(horiz_chart, 'select', selectHandler);

            horiz_chart.draw(merged_table, google.charts.Bar.convertOptions(options_horiz_bar));
            
            var options_pie = {
                title: 'Proportion of selected classes',
                width: 900,
                height: 500,
            };

            var pie_chart = new google.visualization.PieChart(document.getElementById('pieDiv'));

            pie_chart.draw(merged_table, options_pie);


            //Draw the scatter plot chart
            all_rows = [];
            for (var i = 0; i < dataset_categories.getNumberOfRows(); i++) {
                all_rows.push(i);
            }
            var data_line = getLineChartValues(all_rows, dataset_categories, dataset_catToImgs, dataset_ImgsIds);
            var options_line = {
                    hAxis: {
                    title: 'Number of Objects',
                    logScale: false,
                    minValue: 0,
                    format: '0'
                    },
                    vAxis: {
                    title: 'Number of Images',
                    logScale: false,
                    minValue: 0
                    },
            };
            var line_chart = new google.visualization.ScatterChart(document.getElementById('lineDiv'));
            line_chart.draw(data_line, options_line);
        }

        function drawScaleImbalanceDash(dataset_annotations){
            
            const threshold1 = document.getElementById('down_thresh');
            const threshold2 = document.getElementById('up_thresh');
            var thresh1 = 100;
            var thresh2 = 150;
            // max_val = 5000; //TODO: get max from data
            threshold1.value = thresh1;
            threshold2.value = thresh2;

            var _thresh1 = thresh1*thresh1;
            var _thresh2 = thresh2*thresh2;

            const inputHandler = function(e) {
                const passed_value = parseInt(e.target.value);
                if (this.id == "down_thresh"){
                    // if (passed_value >= 0 && passed_value <= thresh2 && passed_value <= max_val){
                    if (passed_value >= 0 && passed_value <= thresh2){
                        thresh1 = passed_value;
                        _thresh1 = thresh1*thresh1;
                    } else {
                        e.target.value = thresh1;
                    }
                } else {
                    if(this.id == "up_thresh"){
                        // if (passed_value >= 0 && passed_value >= thresh1 && passed_value <= max_val){
                        if (passed_value >= 0 && passed_value >= thresh1){
                            thresh2 = passed_value;
                            _thresh2 = thresh2*thresh2;
                        } else {
                            e.target.value = thresh2;
                        }
                    }
                }

                //redrawing the chart
                drawStackedBar(dataset_annotations, _thresh1, _thresh2);
            };
            threshold1.addEventListener('input', inputHandler);
            threshold2.addEventListener('input', inputHandler);

            drawParallelCoordChart(dataset_annotations);
            drawStackedBar(dataset_annotations, _thresh1, _thresh2);
        }

        function drawParallelCoordChart(dataset_annotations){
            var margin = {top: 30, right: 10, bottom: 10, left: 10},
                        width = 960 - margin.left - margin.right,
                        height = 500 - margin.top - margin.bottom;
            
            var x = d3.scale.ordinal().rangePoints([0, width], 1),
            // var x = d3.scaleBand().range([0, width], 1),
                y = {},
                dragging = {};

            var line = d3.svg.line(),
                axis = d3.svg.axis().orient("left"),
                background,
                foreground;

            var svg = d3.select("#parallelDiv").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            
            // var data_stacked = new google.visualization.DataView(dataset_annotations);
            var merged_table = google.visualization.data.join(dataset_annotations, dataset_categories,
                                'left', [[5,0]], [0,3,4,9,10], [1]);
            var data_stacked = new google.visualization.DataView(merged_table);
            data_stacked.setColumns([6,1,2,3,4,5]);
            
            var csvFormattedDataTable = google.visualization.dataTableToCsv(data_stacked.toDataTable());
            console.log(csvFormattedDataTable);
            var data_parallel = d3.csv.parseRows(csvFormattedDataTable, function(d) {
                return {
                    class: d[0],
                    area: parseInt(d[1].replace(/,/g, "")),
                    width: parseInt(d[2].replace(/,/g, "")),
                    height: parseInt(d[3].replace(/,/g, "")),
                    center_x: parseInt(d[4].replace(/,/g, "")),
                    centerY: parseInt(d[5].replace(/,/g, ""))
                };
            });

            var domain_y = [];
            for (var rowIndex=0; rowIndex < dataset_categories.getNumberOfRows(); rowIndex++){
                domain_y.push(dataset_categories.getValue(rowIndex, 1)); 
            };
            // Extracting the list of dimensions and create a scale for each.
            x.domain(dimensions = d3.keys(data_parallel[0]).filter(function(d) {
                    if (d == "class") { //the only categorical class here
                        return y[d] = d3.scale.ordinal()
                            .domain(domain_y)
                            .rangePoints([height, 0]);
                            // .paddingInner([0.1]);
                    } else {
                        return y[d] = d3.scale.linear()
                            // .domain(d3.extent(data_parallel, function(p) { return +p[d]; }))
                            .domain(d3.extent(data_parallel, p=>p[d]))
                            .range([height, 0]);
                }
            }));

            // Add grey background lines for context.
            background = svg.append("g")
                .attr("class", "background")
                .selectAll("path")
                .data(data_parallel)
                .enter().append("path")
                .attr("d", path);

            // Add blue foreground lines for focus.
            foreground = svg.append("g")
                .attr("class", "foreground")
                .selectAll("path")
                .data(data_parallel)
                .enter().append("path")
                .attr("d", path);

            // Add a group element for each dimension.
            var g = svg.selectAll(".dimension")
                .data(dimensions)
                .enter().append("g")
                .attr("class", "dimension")
                .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
                .call(d3.behavior.drag()
                    .origin(function(d) { return {x: x(d)}; })
                    .on("dragstart", function(d) {
                    dragging[d] = x(d);
                    background.attr("visibility", "hidden");
                    })
                    .on("drag", function(d) {
                    dragging[d] = Math.min(width, Math.max(0, d3.event.x));
                    foreground.attr("d", path);
                    dimensions.sort(function(a, b) { return position(a) - position(b); });
                    x.domain(dimensions);
                    g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
                    })
                    .on("dragend", function(d) {
                    delete dragging[d];
                    transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
                    transition(foreground).attr("d", path);
                    background
                        .attr("d", path)
                        .transition()
                        .delay(500)
                        .duration(0)
                        .attr("visibility", null);
                    }));

            // Add an axis and title.
            g.append("g")
                .attr("class", "axis")
                .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
                .append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function(d) { return d; });

            // Add and store a brush for each axis.
            g.append("g")
                .attr("class", "brush")
                .each(function(d) {
                    d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
                })
                .selectAll("rect")
                .attr("x", -8)
                .attr("width", 16);

            // AUXILIARY FUNCTIONS FOR PARALLEL COORDINATES CHART
            function position(d) {
            var v = dragging[d];
            return v == null ? x(d) : v;
            }

            function transition(g) {
            return g.transition().duration(500);
            }

            // Returns the path for a given data point.
            function path(d) {
            return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
            }

            function brushstart() {
            d3.event.sourceEvent.stopPropagation();
            }

            // Handles a brush event, toggling the display of foreground lines.
            function brush() {
            var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
                extents = actives.map(function(p) { return y[p].brush.extent(); });
            foreground.style("display", function(d) {
                return actives.every(function(p, i) {
                    if (typeof d[p] === 'string') {
                        var categorical_vaue = y['class'](d[p]);
                        return extents[i][0] <= categorical_vaue && categorical_vaue <= extents[i][1];
                    } else {
                        return extents[i][0] <= d[p] && d[p] <= extents[i][1];

                    }
                }) ? null : "none";
            });
            }
            // END OF AUXILIARY FUNCTIONS FOR PARALLEL COORDINATES CHART
        }
        

        function drawStackedBar(dataset_annotations, _thresh1, _thresh2){
            // getting the relevant data for this view
            var data_stacked = new google.visualization.DataView(dataset_annotations);
            data_stacked.hideColumns([1,2,3,4,5,6,7,8]);

            // counting based on the set threshold values
            var fomatted_data_stacked = google.visualization.data.group(
                data_stacked,
                [{'column': 0, 'modifier': getSize, 'type': 'string'}],
                [{'column': 1, 'aggregation': google.visualization.data.count, 'type': 'number'}]
            );

            function getSize(area) {
                var ret = "medium";
                if(area >= _thresh2) ret = "big";
                else if(area < _thresh1) ret = "small";
                
                return ret;
            }

            // transposing the table
            var row1 = ['Size'];
            var row2 = ['Class Proportion'];
            for (var rowIndex = 0; rowIndex < fomatted_data_stacked.getNumberOfRows(); rowIndex++){
                row1.push(fomatted_data_stacked.getValue(rowIndex, 0));
                row2.push(fomatted_data_stacked.getValue(rowIndex, 1));
            }

            var transposed_stacked_table = google.visualization.arrayToDataTable([row1, row2]);

            var options_fullStacked = {
                isStacked: 'percent',
                height: 300,
                legend: {position: 'top', maxLines: 1},
                hAxis: {
                    minValue: 0,
                    ticks: [0, .25, .5, .75, 1]
                }
            };

            //TODO: fixar a ordem das labels! de small pra big! (atualmente vai a depender dos dados, creio eu)
            var stacked_chart = new google.visualization.BarChart(document.getElementById("stackedDiv"));
            stacked_chart.draw(transposed_stacked_table, options_fullStacked);
        }
        
        function drawLocationImbalanceDash(dataset_categories, dataset_annotations){

        }

        function getLineChartValues(selected_rows, dataset_categories, dataset_catToImgs, dataset_ImgsIds) {
            const countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
            var imageOccurrences = {};
            for (var key of selected_rows) {
                var cat = dataset_categories.getValue(Number(key), 1);
                imageOccurrences[cat] = {};
                for (var img_id of dataset_ImgsIds) {
                    var cont = countOccurrences(dataset_catToImgs[key], img_id);
                    if (imageOccurrences[cat][cont] > 0) {
                        imageOccurrences[cat][cont] += 1;
                    } else {
                        imageOccurrences[cat][cont] = 1;
                    }
                }
            }
            data_line_raw = [['x']];
            for (i of selected_rows) {
                data_line_raw[0].push(dataset_categories.getValue(i, 1));
            }
            var max_value = 0;
            for (i of Object.keys(imageOccurrences)) {
                const max_class = Math.max.apply(Math, Object.keys(imageOccurrences[i]));
                if (max_value < max_class) {
                    max_value = max_class;
                }
            }
            for (var i = 0; i <= max_value; i++) {
                data_line_raw.push([i]);
                for (j of selected_rows) {
                    var cat = dataset_categories.getValue(j, 1);
                    if (imageOccurrences[cat][i] > 0) {
                        data_line_raw[i+1].push(imageOccurrences[cat][i]);
                    } else {
                        data_line_raw[i+1].push(0);
                    }
                }
            }
            return google.visualization.arrayToDataTable(data_line_raw);
        }
    </script>
</body>
</html>