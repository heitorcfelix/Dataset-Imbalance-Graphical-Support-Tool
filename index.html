<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <!-- <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script> -->

    <style>
        .headingDiv {
            width: 994px;
            border: 5px outset grey;
            text-align: center;
        }

        svg {
            font: 10px sans-serif;
        }

        .background path {
            fill: none;
            stroke: #ddd;
            shape-rendering: crispEdges;
        } 

        .foreground path {
            fill: none;
            stroke: steelblue;
        }

        .brush .extent  {
            fill-opacity: .3;
            stroke: #fff;
            shape-rendering: crispEdges;
        }

        .axis line,
        .axis path {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }

        .axis text {
            text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
            cursor: move;
        }

        #classImbDiv {
            visibility: hidden;
            width: 1000px;
        } 
        
        #scaleImbDiv {
            visibility: hidden;
            width: 1004px;
            position: absolute;
            top: 1200px;
        }
        
        #objLocImbDiv {
            visibility: hidden;
            width: 1000px;
            position: absolute;
            top: 1950px;
        }

        .classImbTitle, .scaleImbTitle, .objLocImbTitle{
            width: 1000;
            text-align: center;
        }

        /* .scaleImbTitle
        {
            width: 870;
            text-align: center;
        } */

        #horizBarDiv {
            position: absolute;
            top: 200px;
            border: 2px outset grey;
            width: 500px;
            height: 1000px;
        }
        #pieDiv {
            position: absolute;
            top: 200px;
            left: 510px;
            border: 2px outset grey;
            width: 500px;
            height: 500px;
        }
        #lineDiv {
            position: absolute;
            top: 700px;
            left: 510px;
            border: 2px outset grey;
            width: 500px;
            height: 500px;
        }

        #down_thresh, #up_thresh {
            width: 5ch;
        }
        #stackedControlDiv {
            border: 2px outset grey;
            position: absolute;
            top: 573px;
            width: 250px;
            height: 170px;
        }
        #parallelDiv {
            border: 2px outset grey;
        }
        #stackedDiv {
            border: 2px outset grey;
            position: absolute;
            top: 573px;
            left: 250px;
            width: 750px;
            height: 170px;
        }
        #heatMapDiv {
            border: 2px outset grey;
            width: 1000px;
        }
        
    </style>
</head>

<body>
    <div class="headingDiv">
        <h1>Dataset Imbalance Graphical Suport Tool</h1>
        <p> Chosen dataset for analisys: <input type="file" onchange="loadFile()" /></p>
    </div>
    <div id="classImbDiv">
        <h2 class="classImbTitle">Class Imbalance</h1>
        <div id="horizBarDiv"></div>
        <div id="pieDiv"></div>
        <div id="lineDiv"></div>
    </div>
    <div id="scaleImbDiv">
        <h2 class="scaleImbTitle">Scale Imbalance</h1>
            <div id="parallelDiv"></div>
            <div id="stackedControlDiv">
                <h3>Boundingboxes scales:</h3>
                <p>Small: Up to <span id="label_thresh_low"></span>² pixels</p>
                <p>Medium: <input type="number" id="down_thresh">² to <input type="number" id="up_thresh">² pixels</p>
                <p>Big: Over <span id="label_thresh_high"></span>² pixels</p>

            </div>
            <div id="stackedDiv">
            </div>
    </div>
    <div id="objLocImbDiv">
        <h2 class="objLocImbTitle">Object Location Imbalance</h1>
        <div id="heatMapDiv"></div>
    </div>
    <!-- TODO: tirar <<DEBUG>> -->
    <div id="debugDiv">
        <div id="debugDiv1"></div>
        <div id="debugDiv2"></div>
        <div id="debugDiv3"></div>
        <div id="debugDiv4"></div>
        <div id="debugDiv5"></div>
        <div id="debugDiv6"></div>
    </div>

    <script>
        //Loading all from google chart API that will be used
        google.charts.load('current', {'packages':['bar']});
        google.charts.load('current', {'packages':['corechart']});
        google.charts.load('current', {'packages':['table']}); //TODO: tirar <<DEBUG>>

        //Some globals that every chart can access
        var current_selected_classes = [];
        var _thresh1 , _thresh2;

        //open the file uploaded by user
        var reader = new FileReader();  
    
        function loadFile() {      
            var file = document.querySelector('input[type=file]').files[0];

            reader.addEventListener("load", parseFile, false);
            if (file) {
                reader.readAsText(file);
            }
        }
    
        //Parse the uploaded JSON
        function parseFile(){
            var data_json = JSON.parse(reader.result);
            // console.log(data_json);
            // reading the data and formatting in order to be easier to work with it in google charts
            dataset_info = new google.visualization.DataTable();
            dataset_info.addColumn('string', 'contributor');
            dataset_info.addColumn('string', 'date_created');
            dataset_info.addColumn('string', 'description');
            dataset_info.addColumn('string', 'url');
            dataset_info.addColumn('string', 'version');
            dataset_info.addColumn('number', 'year');

            dataset_info.addRow([data_json.info.contributor, 
                        data_json.info.date_created,
                        data_json.info.description,
                        data_json.info.url,
                        data_json.info.version,
                        data_json.info.year]);

            // TODO
            // dataset_licenses = ;

            dataset_categories = new google.visualization.DataTable();
            dataset_categories.addColumn('number', 'id');
            dataset_categories.addColumn('string', 'name');
            dataset_categories.addColumn('string', 'supercategory');

            for (var i = 0; i < data_json.categories.length; i++) {
                dataset_categories.addRow([data_json.categories[i].id,
                                            data_json.categories[i].name,
                                            data_json.categories[i].supercategory]);
            }

            dataset_images = new google.visualization.DataTable();
            dataset_images.addColumn('string', 'id');
            dataset_images.addColumn('number', 'width');
            dataset_images.addColumn('number', 'height');
            dataset_images.addColumn('string', 'file_name');
            dataset_images.addColumn('number', 'license');
            dataset_images.addColumn('string', 'flickr_url');
            dataset_images.addColumn('string', 'coco_url');
            dataset_images.addColumn('string', 'date_captured');

            dataset_ImgsIds = []

            for (var i = 0; i < data_json.images.length; i++) {
                dataset_images.addRow([data_json.images[i].id,
                                        data_json.images[i].width,
                                        data_json.images[i].height,
                                        data_json.images[i].file_name,
                                        data_json.images[i].license,
                                        data_json.images[i].flickr_url,
                                        data_json.images[i].coco_url,
                                        data_json.images[i].date_captured]);
                dataset_ImgsIds.push(data_json.images[i].id)
            }

            dataset_annotations = new google.visualization.DataTable();
            dataset_annotations.addColumn('number', 'area');
            dataset_annotations.addColumn('number', 'topLeftX');
            dataset_annotations.addColumn('number', 'topLeftY');
            dataset_annotations.addColumn('number', 'width');
            dataset_annotations.addColumn('number', 'height');
            dataset_annotations.addColumn('number', 'category_id');
            dataset_annotations.addColumn('number', 'id');
            dataset_annotations.addColumn('string', 'image_id');
            dataset_annotations.addColumn('number', 'is_crowd');
            dataset_annotations.addColumn('number', 'center_x');
            dataset_annotations.addColumn('number', 'center_y');
            // dataset_categories.addColumn('????', 'segmentation');
            dataset_catToImgs = {}

            for (var i = 0; i < data_json.annotations.length; i++) {
                var center_x = data_json.annotations[i].bbox[0] + Math.round(data_json.annotations[i].bbox[2] / 2);
                var center_y = data_json.annotations[i].bbox[1] + Math.round(data_json.annotations[i].bbox[3] / 2);
                dataset_annotations.addRow([data_json.annotations[i].area,
                                            data_json.annotations[i].bbox[0],
                                            data_json.annotations[i].bbox[1],
                                            data_json.annotations[i].bbox[2],
                                            data_json.annotations[i].bbox[3],
                                            data_json.annotations[i].category_id,
                                            data_json.annotations[i].id,
                                            data_json.annotations[i].image_id,
                                            data_json.annotations[i].iscrowd,
                                            center_x,
                                            center_y]);
                if (dataset_catToImgs[data_json.annotations[i].category_id] != undefined){
                    dataset_catToImgs[data_json.annotations[i].category_id].push(data_json.annotations[i].image_id)
                } else {
                    dataset_catToImgs[data_json.annotations[i].category_id] = []
                    dataset_catToImgs[data_json.annotations[i].category_id].push(data_json.annotations[i].image_id)
                }
            }
            
            //TODO: tirar <<DEBUG>>
            // var table = new google.visualization.Table(document.getElementById('debugDiv1'));
            // table.draw(dataset_info, {showRowNumber: true, width: '100%', height: '100%'});
            // table = new google.visualization.Table(document.getElementById('debugDiv2'));
            // table.draw(dataset_categories, {showRowNumber: true, width: '100%', height: '100%'});
            // table = new google.visualization.Table(document.getElementById('debugDiv3'));
            // table.draw(dataset_annotations, {showRowNumber: true, width: '100%', height: '100%'});

            // TODO: talvez mostrar na tela as informações da base (dataset_info)
            
            //Set divs visibility so the content is shown
            document.getElementById("classImbDiv").style.visibility = "visible";
            document.getElementById("scaleImbDiv").style.visibility = "visible";
            document.getElementById("objLocImbDiv").style.visibility = "visible";

            //Draw each dashboard
            drawClassImbalanceDash(dataset_categories, dataset_annotations, dataset_catToImgs, dataset_ImgsIds, dataset_images);
            drawScaleImbalanceDash(dataset_annotations, dataset_categories);
            drawLocationImbalanceDash(dataset_categories, dataset_annotations, dataset_images, []);
        }

        function drawClassImbalanceDash(dataset_categories, dataset_annotations, dataset_catToImgs, dataset_ImgsIds, dataset_images){
            // group by class name
            var grouped_table = google.visualization.data.group(dataset_annotations, [5], 
                        [{'column': 5, 'aggregation': google.visualization.data.count, 'type': 'number'}]);
            
            // merging information to get class names
            var merged_table = google.visualization.data.join(dataset_categories, grouped_table,
                                'right', [[0,0]], [1], [1]);
            
            // removing the id column (only used to match both tables)
            merged_table.removeColumn(0);
            merged_table.setColumnLabel(0, "Class");
            merged_table.setColumnLabel(1, "Count");
            merged_table.sort({column: 1, desc: true});

            var options_horiz_bar = {
                title: 'Total instances per class',
                legend: { position: "none" },
                // hAxis: { ticks: [5,10,20,50] },
                hAxis: { gridlines: { interval: [10, 20, 100, 1000] } },
                bars: 'horizontal',
                selectionMode: 'multiple',
                width: 450,
                height: 950
            };

            var horiz_chart = new google.charts.Bar(document.getElementById('horizBarDiv'));

            // The select handler. Call the chart's getSelection() method
            function selectHandler() {
                var selectedItem = horiz_chart.getSelection();
                if (selectedItem) {
                    if (selectedItem.length > 0) {
                        current_selected_classes = [];
                        selectedItem.forEach(element => {
                            current_selected_classes.push(element.row);
                        });
                        var old_selected_classes = [];
                        for (i of current_selected_classes) {
                            class_name = merged_table.getValue(i, 0);
                            for (var j = 0; j < dataset_categories.getNumberOfRows(); j++) {
                                if (class_name == dataset_categories.getValue(j, 1)) {
                                    old_selected_classes.push(j);
                                }
                            }
                        }
                        var view = new google.visualization.DataView(merged_table);
                        view.setRows(current_selected_classes);
                        pie_chart.draw(view, options_pie);
                        data_line = getLineChartValues(old_selected_classes, dataset_categories, dataset_catToImgs, dataset_ImgsIds);
                        line_chart.draw(data_line, options_line);
                        drawParallelCoordChart(dataset_annotations, dataset_categories, old_selected_classes);
                        drawStackedBar(dataset_annotations, old_selected_classes);
                        drawLocationImbalanceDash(dataset_categories, dataset_annotations, dataset_images, old_selected_classes)
                    } else {
                        pie_chart.draw(merged_table, options_pie);
                        all_rows = [];
                        for (var i = 0; i < dataset_categories.getNumberOfRows(); i++) {
                            all_rows.push(i);
                        }
                        data_line = getLineChartValues(all_rows, dataset_categories, dataset_catToImgs, dataset_ImgsIds);
                        line_chart.draw(data_line, options_line);
                        drawParallelCoordChart(dataset_annotations, dataset_categories, []);
                        drawStackedBar(dataset_annotations, []);
                        drawLocationImbalanceDash(dataset_categories, dataset_annotations, dataset_images, [])
                    }
                }
            }

            // Listen for the 'select' event, and call my function selectHandler() when
            // the user selects something on the chart.
            google.visualization.events.addListener(horiz_chart, 'select', selectHandler);

            horiz_chart.draw(merged_table, google.charts.Bar.convertOptions(options_horiz_bar));
            
            var options_pie = {
                title: 'Proportion of selected classes',
                legend: { position: 'top', maxLines: 3 },
                // width: 500,
                // height: 500
                width: '100%',
                height: '100%'
            };

            var pie_chart = new google.visualization.PieChart(document.getElementById('pieDiv'));

            pie_chart.draw(merged_table, options_pie);


            //Draw the scatter plot chart
            all_rows = [];
            for (var i = 0; i < dataset_categories.getNumberOfRows(); i++) {
                all_rows.push(i);
            }
            var data_line = getLineChartValues(all_rows, dataset_categories, dataset_catToImgs, dataset_ImgsIds);
            var options_line = {
                legend: { position: 'top', maxLines: 3 },
                width: '100%',
                hAxis: {
                title: 'Number of Objects',
                logScale: false,
                minValue: 0,
                format: '0'
                },
                vAxis: {
                title: 'Number of Images',
                logScale: false,
                minValue: 0
                }
            };
            var line_chart = new google.visualization.ScatterChart(document.getElementById('lineDiv'));
            line_chart.draw(data_line, options_line);
        }

        function drawScaleImbalanceDash(dataset_annotations, dataset_categories){
            
            const threshold1 = document.getElementById('down_thresh');
            const threshold2 = document.getElementById('up_thresh');
            var thresh1 = 100;
            var thresh2 = 150;

            document.getElementById("label_thresh_low").innerHTML = thresh1;
            document.getElementById("label_thresh_high").innerHTML = thresh2;

            threshold1.value = thresh1;
            threshold2.value = thresh2;

            _thresh1 = thresh1*thresh1;
            _thresh2 = thresh2*thresh2;

            const inputHandler = function(e) {
                const passed_value = parseInt(e.target.value);
                if (this.id == "down_thresh"){
                    if (passed_value >= 0 && passed_value <= thresh2){
                        thresh1 = passed_value;
                        _thresh1 = thresh1*thresh1;
                    } else {
                        e.target.value = thresh1;
                    }
                    document.getElementById("label_thresh_low").innerHTML = thresh1;
                } else {
                    if(this.id == "up_thresh"){
                        if (passed_value >= 0 && passed_value >= thresh1){
                            thresh2 = passed_value;
                            _thresh2 = thresh2*thresh2;
                        } else {
                            e.target.value = thresh2;
                        }
                        document.getElementById("label_thresh_high").innerHTML = thresh2;
                    }
                }

                //redrawing the chart
                drawStackedBar(dataset_annotations, _thresh1, _thresh2);
            };
            threshold1.addEventListener('input', inputHandler);
            threshold2.addEventListener('input', inputHandler);

            drawStackedBar(dataset_annotations, current_selected_classes);
            drawParallelCoordChart(dataset_annotations, dataset_categories, current_selected_classes);
        }

        function drawParallelCoordChart(dataset_annotations, dataset_categories, current_selected_classes){
            //deleting previous svg, if any
            d3.select("#parallelDiv").select("svg").remove();

            //drawing new chart
            var margin = {top: 30, right: 10, bottom: 10, left: 10},
                        width = 1000 - margin.left - margin.right,
                        height = 500 - margin.top - margin.bottom;
            
            var x = d3.scale.ordinal().rangePoints([0, width], 1),
                y = {},
                dragging = {};

            var line = d3.svg.line(),
                axis = d3.svg.axis().orient("left"),
                background,
                foreground;

            var svg = d3.select("#parallelDiv").append("svg")
            
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            
            var selected_cols_data = new google.visualization.DataView(dataset_annotations);
            if (current_selected_classes.length > 0){
                selected_cols_data.setRows(selected_cols_data.getFilteredRows([{column: 5, 
                    test: function(value, rowId, columnId, datatable) { 
                        var match_value = false;
                        current_selected_classes.forEach(element => {
                            match_value = (match_value || (value === element)); });
                        return match_value; }
                    }]));
            }
            var merged_table = google.visualization.data.join(selected_cols_data, dataset_categories,
                                'left', [[5,0]], [0,3,4,9,10], [1]);
            var data_stacked = new google.visualization.DataView(merged_table);
            data_stacked.setColumns([6,1,2,3,4,5]);
            
            
            var csvFormattedDataTable = google.visualization.dataTableToCsv(data_stacked.toDataTable());
            var data_parallel = d3.csv.parseRows(csvFormattedDataTable, function(d) {
                return {
                    class: d[0],
                    area: parseInt(d[1].replace(/,/g, "")),
                    width: parseInt(d[2].replace(/,/g, "")),
                    height: parseInt(d[3].replace(/,/g, "")),
                    center_x: parseInt(d[4].replace(/,/g, "")),
                    centerY: parseInt(d[5].replace(/,/g, ""))
                };
            });

            var domain_y = [];
            for (var rowIndex=0; rowIndex < dataset_categories.getNumberOfRows(); rowIndex++){
                domain_y.push(dataset_categories.getValue(rowIndex, 1)); 
            };
            // Extracting the list of dimensions and create a scale for each.
            x.domain(dimensions = d3.keys(data_parallel[0]).filter(function(d) {
                    if (d == "class") { //the only categorical class here
                        return y[d] = d3.scale.ordinal()
                            .domain(domain_y)
                            .rangePoints([height, 0]);
                    } else {
                        return y[d] = d3.scale.linear()
                            .domain(d3.extent(data_parallel, p=>p[d]))
                            .range([height, 0]);
                }
            }));

            // Add grey background lines for context.
            background = svg.append("g")
                .attr("class", "background")
                .selectAll("path")
                .data(data_parallel)
                .enter().append("path")
                .attr("d", path);

            // Add blue foreground lines for focus.
            foreground = svg.append("g")
                .attr("class", "foreground")
                .selectAll("path")
                .data(data_parallel)
                .enter().append("path")
                .attr("d", path);

            // Add a group element for each dimension.
            var g = svg.selectAll(".dimension")
                .data(dimensions)
                .enter().append("g")
                .attr("class", "dimension")
                .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
                .call(d3.behavior.drag()
                    .origin(function(d) { return {x: x(d)}; })
                    .on("dragstart", function(d) {
                    dragging[d] = x(d);
                    background.attr("visibility", "hidden");
                    })
                    .on("drag", function(d) {
                    dragging[d] = Math.min(width, Math.max(0, d3.event.x));
                    foreground.attr("d", path);
                    dimensions.sort(function(a, b) { return position(a) - position(b); });
                    x.domain(dimensions);
                    g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
                    })
                    .on("dragend", function(d) {
                    delete dragging[d];
                    transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
                    transition(foreground).attr("d", path);
                    background
                        .attr("d", path)
                        .transition()
                        .delay(500)
                        .duration(0)
                        .attr("visibility", null);
                    }));

            // Add an axis and title.
            g.append("g")
                .attr("class", "axis")
                .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
                .append("text")
                .style("text-anchor", "middle")
                .style("font-weight", "bold")
                .attr("y", -9)
                .text(function(d) { return d; });

            // Add and store a brush for each axis.
            g.append("g")
                .attr("class", "brush")
                .each(function(d) {
                    d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush));
                })
                .selectAll("rect")
                .attr("x", -8)
                .attr("width", 16);

            // AUXILIARY FUNCTIONS FOR PARALLEL COORDINATES CHART
            function position(d) {
            var v = dragging[d];
            return v == null ? x(d) : v;
            }

            function transition(g) {
            return g.transition().duration(500);
            }

            // Returns the path for a given data point.
            function path(d) {
            return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
            }

            function brushstart() {
            d3.event.sourceEvent.stopPropagation();
            }

            // Handles a brush event, toggling the display of foreground lines.
            function brush() {
            var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
                extents = actives.map(function(p) { return y[p].brush.extent(); });
            foreground.style("display", function(d) {
                return actives.every(function(p, i) {
                    if (typeof d[p] === 'string') {
                        var categorical_vaue = y['class'](d[p]);
                        return extents[i][0] <= categorical_vaue && categorical_vaue <= extents[i][1];
                    } else {
                        return extents[i][0] <= d[p] && d[p] <= extents[i][1];

                    }
                }) ? null : "none";
            });
            }
            // END OF AUXILIARY FUNCTIONS FOR PARALLEL COORDINATES CHART
        }
        

        function drawStackedBar(dataset_annotations, current_selected_classes){
            // getting the relevant data for this view
            var data_stacked = new google.visualization.DataView(dataset_annotations);
            if (current_selected_classes.length > 0){
                data_stacked.setRows(data_stacked.getFilteredRows([{column: 5, 
                    test: function(value, rowId, columnId, datatable) { 
                        var match_value = false;
                        current_selected_classes.forEach(element => {
                            match_value = (match_value || (value === element)); });
                        return match_value; }
                    }]));
            }
            data_stacked.hideColumns([1,2,3,4,5,6,7,8]);

            // counting based on the set threshold values
            var fomatted_data_stacked = google.visualization.data.group(
                data_stacked,
                [{'column': 0, 'modifier': getSize, 'type': 'string'}],
                [{'column': 1, 'aggregation': google.visualization.data.count, 'type': 'number'}]
            );

            function getSize(area) {
                var ret = "Medium";
                if(area >= _thresh2) ret = "Big";
                else if(area < _thresh1) ret = "Small";
                
                return ret;
            }

            var transposed_stacked_table = new google.visualization.DataTable();
            transposed_stacked_table.addColumn('string', 'Size');
            transposed_stacked_table.addColumn('number', 'Small');
            transposed_stacked_table.addColumn('number', 'Medium');
            transposed_stacked_table.addColumn('number', 'Big');
            transposed_stacked_table.addRow(["Class Proportion", 0, 0 ,0]);
            for (var rowIndex = 0; rowIndex < fomatted_data_stacked.getNumberOfRows(); rowIndex++){
                var row1 = fomatted_data_stacked.getValue(rowIndex, 0);
                var row2 = fomatted_data_stacked.getValue(rowIndex, 1);
                if(row1 === 'Small') {
                    transposed_stacked_table.setCell(0,1, row2);
                } else if (row1 === 'Medium') {
                    transposed_stacked_table.setCell(0,2, row2);
                } else if (row1 === 'Big') {
                    transposed_stacked_table.setCell(0,3, row2);
                }
            }

            var view_stacked_table = new google.visualization.DataView(transposed_stacked_table);

            var options_fullStacked = {
                isStacked: 'percent',
                height: '100%',
                width: '100%',
                legend: {position: 'top', maxLines: 1},
                hAxis: {
                    minValue: 0,
                    ticks: [0, .25, .5, .75, 1]
                }
            };

            var stacked_chart = new google.visualization.BarChart(document.getElementById("stackedDiv"));
            stacked_chart.draw(view_stacked_table, options_fullStacked);
        }
        
        function drawLocationImbalanceDash(dataset_categories, dataset_annotations, dataset_images, old_selected_classes){
            d3.select("#heatMapDiv").selectAll("svg").remove();

            if (old_selected_classes.length <= 0) {
                var old_selected_classes = [];
                for (var row = 0; row < dataset_categories.getNumberOfRows(); row++) {
                    old_selected_classes.push(dataset_categories.getValue(row,0));
                }
            }
            var selected_rows = [];
            var view_categories = new google.visualization.DataView(dataset_categories);
            for (cat of old_selected_classes) {
                for (var row = 0; row < dataset_categories.getNumberOfRows(); row++) {
                    if (dataset_categories.getValue(row,0) == cat) {
                        selected_rows.push(cat);
                    }
                }
            }
            view_categories.setRows(selected_rows)

            var merged_table = google.visualization.data.join(dataset_annotations, dataset_categories,
                                'left', [[5,0]], [7,9,10], [1]);
            var merged_table = google.visualization.data.join(merged_table, dataset_images,
                                'left', [[1,0]], [0,2,3,4], [1,2]);
            var data_stacked = new google.visualization.DataView(merged_table);
            data_stacked.setColumns([1,2,3,5,6,4]);

            var grouped_table = google.visualization.data.group(dataset_annotations, [5], 
                        [{'column': 5, 'aggregation': google.visualization.data.count, 'type': 'number'}]);

            var cats = [];
            var data = [];
            var data_matrix = [];
            for (var rowIndex=0; rowIndex < view_categories.getNumberOfRows(); rowIndex++){
                cats.push(view_categories.getValue(rowIndex, 0));
                data.push([]);
                data_matrix[rowIndex] = [];
                for (var row=0; row < 9; row++){
                    data_matrix[rowIndex][row] = [];
                    for (var col=0; col < 9; col++){
                        data_matrix[rowIndex][row][col] = 0;
                    }
                };
            };
            
            for (var row = 0; row < data_stacked.getNumberOfRows(); row++) {
                for (var i = 0; i < view_categories.getNumberOfRows(); i++) {
                    if (data_stacked.getValue(row,0) == view_categories.getValue(i,0)) {
                        const x_axis = Math.floor(data_stacked.getValue(row, 1)/data_stacked.getValue(row, 3)*8);
                        const y_axis = Math.floor(data_stacked.getValue(row, 2)/data_stacked.getValue(row, 4)*8);
                        data_matrix[i][y_axis][x_axis] += 1;
                    }
                }
            }
            for (var rowIndex=0; rowIndex < view_categories.getNumberOfRows(); rowIndex++){
                data[rowIndex] = [];
                for (var row=0; row < 9; row++){
                    for (var col=0; col < 9; col++){
                        data[rowIndex].push({group: col, variable: row, value: data_matrix[rowIndex][row][col]});
                    }
                };
            };

            // set the dimensions and margins of the graph
            var margin = {top: 50, right: 50, bottom: 50, left: 50},
                width = 450 - margin.left - margin.right,
                height = 450 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#heatMapDiv")
                        .selectAll("svg")
                        .data(cats)
                        .enter()
                        .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .attr("id", function(d, i) { return "heatmap_" + i; })
                        .append("g")
                        .attr("class", "heatClassLabel")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

            // Putting a title on each heatmap
            d3.select("#heatMapDiv")
                .selectAll("svg")
                .append("g")
                .append("text")
                .attr("x", 10)
                .attr("y", margin.top-5)
                .style("font-weight", "bold")
                .style("font-size", "20px")
                .text(function(d) { 
                var class_label = "error";
                for (var i = 0; i < dataset_categories.getNumberOfRows(); i++){
                    if (d === dataset_categories.getValue(d, 0)) {
                        class_label = dataset_categories.getValue(d, 1);
                    }
                }
                return class_label; });
            
            var myGroups = [0,1,2,3,4,5,6,7,8,9]
            var myVars = [0,1,2,3,4,5,6,7,8,9]
            // Build X scales and axis:
            var x = d3.scale.ordinal()
                    .rangePoints([0, width])
                    // .range([ 0, width ])
                    .domain(myGroups);
                    // .padding(0.05);
            // Build Y scales and axis:
            var y = d3.scale.ordinal()
                    .rangePoints([0, width])
                    // .range([ height, 0 ])
                    .domain(myVars);
                    // .padding(0.05);
            
            // Build color scale
            var myColor = d3.scale.linear()
                            .domain([1,100])
                            .interpolate(d3.interpolateHcl)
                            .range([d3.rgb("#007AFF"), d3.rgb('#FFF500')]);

            // Create color scale bar
            var rects = d3.select("#heatMapDiv")
                        .selectAll("svg")
                        .selectAll(".rects")
                        .data(d3.range(0,100,2)) //number of small rects that forms the scale
                        .enter()
                        .append("rect")
                        .attr("y", (d,i)=>50 + i*5)
                        .attr("height", 5)
                        .attr("x", 395)
                        .attr("width", 20)
                        .attr("fill", d=>myColor(100-d));
                        // .attr("stroke", "gray");

            // Create label of color scale bar
            var rects = d3.select("#heatMapDiv")
                        .selectAll("svg")
                        .selectAll(".scaleBarLabel")
                        .data([100, 75, 50, 25, 0]) //TODO: substituir pelo min e max de cada heatmap!!
                        .enter()
                        .append("text")
                        .attr("text-anchor", "end")
                        .attr("x", 390)
                        .attr("y", (d,i)=>55 + i*61)
                        .text(d=>d);

            
            // create a tooltip
            var tooltip = d3.select("#heatMapDiv")
                            .append("div")
                            .style("opacity", 0)
                            .attr("class", "tooltip")
                            .style("position", "absolute")
                            .style("background-color", "white")
                            .style("border", "solid")
                            .style("border-width", "2px")
                            .style("border-radius", "5px")
                            .style("padding", "5px");
            
            // Three function that change the tooltip when user hover / move / leave a cell
            var mouseover = function(d) {
                tooltip.style("opacity", 1)
                d3.select(this)
                .style("stroke", "black")
                .style("opacity", 1);
            }
            var mousemove = function(d) {
                tooltip.html("The exact value of<br>this cell is: " + d.value)
                .style("left", (d3.event.pageX+20) + "px")
                .style("top", (d3.event.pageY-1950) + "px");
            }
            var mouseleave = function(d) {
                tooltip.style("opacity", 0)
                d3.select(this)
                .style("stroke", "none")
                .style("opacity", 0.8);
            }

            // add the squares
            // for (i in cats) {
            //     d3.select("svg#heatmap_"+i)
            //     .selectAll("text")
            //     .append("text")
            //     .attr("x", 0)
            //     .attr("y", -20)
            //     .attr("text-anchor", "left")
            //     .style("font-size", "14px")
            //     .style("fill", "grey")
            //     .style("max-width", 400);
            //     // .text("A short description of the take-away message of this chart." + i);
            // }
            
            // add the squares
            for (i in cats) {
                d3.select("svg#heatmap_"+i)
                .selectAll("rect")
                .data(data[i], function(d) {return d.group+':'+d.variable;})
                .enter()
                .append("rect")
                .attr("x", function(d) { return 10 + x(d.group) })
                .attr("y", function(d) { return y(d.variable) + margin.bottom})
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("width", 38)
                .attr("height", 38)
                .style("fill", function(d) { return myColor(d.value/grouped_table.getValue(old_selected_classes[i],1)*100)} )
                .style("stroke-width", 4)
                .style("stroke", "none")
                .style("opacity", 0.8)
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseout", mouseleave);
            }
        }

        function getLineChartValues(selected_rows, dataset_categories, dataset_catToImgs, dataset_ImgsIds) {
            const countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);
            var imageOccurrences = {};
            for (var key of selected_rows) {
                var cat = dataset_categories.getValue(Number(key), 1);
                imageOccurrences[cat] = {};
                for (var img_id of dataset_ImgsIds) {
                    var cont = countOccurrences(dataset_catToImgs[key], img_id);
                    if (imageOccurrences[cat][cont] > 0) {
                        imageOccurrences[cat][cont] += 1;
                    } else {
                        imageOccurrences[cat][cont] = 1;
                    }
                }
            }
            data_line_raw = [['x']];
            for (i of selected_rows) {
                data_line_raw[0].push(dataset_categories.getValue(i, 1));
            }
            var max_value = 0;
            for (i of Object.keys(imageOccurrences)) {
                const max_class = Math.max.apply(Math, Object.keys(imageOccurrences[i]));
                if (max_value < max_class) {
                    max_value = max_class;
                }
            }
            for (var i = 0; i <= max_value; i++) {
                data_line_raw.push([i]);
                for (j of selected_rows) {
                    var cat = dataset_categories.getValue(j, 1);
                    if (imageOccurrences[cat][i] > 0) {
                        data_line_raw[i+1].push(imageOccurrences[cat][i]);
                    } else {
                        data_line_raw[i+1].push(0);
                    }
                }
            }
            return google.visualization.arrayToDataTable(data_line_raw);
        }
    </script>
</body>
</html>